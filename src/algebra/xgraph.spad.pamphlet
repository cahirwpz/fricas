<<common>>=
-- These two macros are necessary to distinguish between Rep and %.
rep x ==> (x@%) pretend Rep
per x ==> (x@Rep) pretend %
-------------------------------------------------------------------

ID ==> Symbol
-- Each vertex and each edge gets a unique id.
-- This ID is only used internally to identify a vertex or an edge
-- and compare two vertices or two edges.
N ==> NonNegativeInteger
Z ==> Integer
-- Category for vertices of a graph.
GraphVertex ==> Join(SetCategory, Comparable)
@


<<category GREDGE GraphEdge>>=
<<common>>
)abbrev category GREDGE GraphEdge
++ Author: Ralf Hemmecke
++ Keywords: graph theory
++ Description:
++ Category for edges of a graph. Edges are supposed to be connected
++ to two vertices.
GraphEdge(V: GraphVertex): Category == GraphVertex with
    vertex1: % -> V
      ++ vertex1(x) returns the first vertex of an edge.
    vertex2: % -> V
      ++ vertex2(x) returns the second vertex of an edge.
@

<<category FGRAPH FinGraph>>=
<<common>>
)abbrev category FGRAPH FinGraph
++ Author: Ralf Hemmecke
++ Keywords: graph theory
++ Description:
++ Category of finite graphs, allows us to model graph theory.
FinGraph(V: GraphVertex, E: GraphEdge V): Category == SetCategory with
    finiteGraph: (List V, List E) -> %
      ++ finiteGraph(vertices, edgees) constructs a graph made
      ++ from vertices and edges.
    insert!: (V, %) -> %
      ++ insert!(v, x) adds a new vertex v to the graph x.
      ++ The function works destructively on x.
    insert!: (E, %) -> %
      ++ insert!(e, x) adds a new edge e and to the graph x
      ++ (including its vertices).
      ++ The function works destructively on x.
    remove!: (V, %) -> %
      ++ remove!(v, x) removes the vertex v and all edges that
      ++ contain v from the graph x.
      ++ The function works destructively on x.
    remove!: (E, %) -> %
      ++ remove!(e, x) removes the edge e from the graph x.
      ++ The function works destructively on x.
    vertices: % -> List V
      ++ vertices(x) returns all vertices of the graph x.
    edges: % -> List E
      ++ edges(x) returns all edges of the graph x.
    member?: % -> (V -> Boolean)
      ++ member?(x)(v) returns true if v is a vertex of graph x, and false
      ++ otherwise.
    degree: % -> (V -> Z)
      ++ If not member?(x)(v), then degree(x)(v) returns -1. Otherwise
      ++ degree(x)(v) is the number of edges of graph x ingoing to vertex v
      ++ or outgoing from it.
      ++ Note: A loop which starts and ends in vertex v counts 2.
    edges: % -> (V -> List E)
      ++ edges(x)(v) returns all edges of x that involve the vertex v.
      ++ edges(x) returns a partial function which is undefined if v is
      ++ not a vertex of x.
    loops: % -> (V -> List E)
      ++ loops(x)(v) returns the edges of graph x that start and end in v.
      ++ loops(x) returns a partial function which is undefined if v is
      ++ not a vertex of x.
    inDegree: % -> (V -> Z)
      ++ inDegree(x)(v) returns the number of ingoing edges of vertex v
      ++ in graph x. If not member?(x)(v), then inDegree(x)(v) returns -1.
      ++ Note: A loop which starts and ends in vertex v counts 1.
      ++ If E is not directed then inDegree(x)(v) counts the number u of
      ++ vertices that are connected to v by an edge and such that
      ++ smaller?(u, v).
    outDegree: % -> (V -> Z)
      ++ outDegree(x)(v) returns the number of outgoing edges of vertex v
      ++ in graph x. If not member?(x)(v), then outDegree(x)(v) returns -1.
      ++ Note: A loop which starts and ends in vertex v counts 1.
      ++ If E is not directed then outDegree(x)(v) counts the number u of
      ++ vertices that are connected to v by an edge and such that
      ++ smaller?(v, u).
    ingoingEdges: % -> (V -> List E)
      ++ ingoingEdges(x)(v) returns a list of ingoing edges (non-loops)
      ++ of vertex v in graph x.
      ++ ingoingEdges(x) returns a partial function which is undefined
      ++ if v is not a vertex of x.
      ++ If E is not directed then ingoingEdges(x)(v) returns all edges e
      ++ for which vertex2 e = v and smaller?(vertex1 e, v).
    outgoingEdges: % -> (V -> List E)
      ++ outgoingEdges(x)(v) returns a list of outgoing edges (non-loops)
      ++ of vertex v in graph x.
      ++ outgoingEdges(x) returns a partial function which is undefined
      ++ if v is not a vertex of x.
      ++ If E is not directed then outgoingEdges(x)(v) returns all edges e
      ++ for which vertex1 e = v and smaller?(v, vertex2 e).
    adjacency: % -> ((V, V) -> N)
      ++ ajacency(x)(v1, v2) returns for a graph x and two vertices v1
      ++ and v2 of the graph the number of edges that connects v1 to v2.
      ++ The outcome of this function is undefined if v1 or v2 are not
      ++ vertices of the graph.
      ++ Condition: member?(x)(v1) and member?(x)(v2).
    adjacencyMatrix: % -> Matrix N
      ++ ajacencyMatrix(x) returns the adjacency matrix of x such that
      ++ the rows and columns correspond to the order of vertices
      ++ given by vertices(x).
      ++ For two vertices u and v, the corresponding entry in the
      ++ matrix gives the number of edges from u to v. If u=v, the matrix
      ++ entry is the number of loops at v.
  add
    ((x: %) = (y: %)): Boolean ==
        -- dummy implementation
        -- We assume the list of vertices and edges are sorted by their
        -- respective id's.
        (vsx, vsy) := (vertices x, vertices y)
        #vsx ~= #vsy => false
        for vx in vsx for vy in vsy repeat if vx ~= vy then return false
        (esx, esy) := (edges x, edges y)
        #esx ~= #esy => false
        for ex in esx for ey in esy repeat if ex ~= ey then return false
        true
    coerce(x: %): OutputForm ==
        vs: List OutputForm := [v::OutputForm for v in vertices x]
        es: List OutputForm := [e::OutputForm for e in edges x]
        bracket [bracket vs, bracket es]
    adjacencyMatrix(x: %): Matrix N ==
        vs: List V := vertices x
        n: N := #vs
        m: Matrix N := new(n, n, 0)
        adj: (V, V) -> N := adjacency x
        for v1 in vs for i in 1.. repeat
            for v2 in vs for j in 1.. repeat qsetelt!(m, i, j, adj(v1, v2))
        m
@

<<category LABELED Labeled>>=
)abbrev category LABELED Labeled
++ Author: Ralf Hemmecke
++ Description:
++ Category for labeled objects.
++ The category Labeled mainly serves as an attribute category.
Labeled(L: SetCategory): Category == with
    label: % -> L
      ++ label(x) returns the label corresponding to x.
@

<<category DIRECT Directed>>=
)abbrev category DIRECT Directed
++ Author: Ralf Hemmecke
++ Description:
++ Category for directed objects.
++ The category Directed only serves as an attribute category.
Directed(): Category == with ()
@

<<domain UVERTEX UnlabeledVertex>>=
<<common>>
)abbrev domain UVERTEX UnlabeledVertex
++ Author: Ralf Hemmecke
++ Keywords: graph theory
++ Description:
++ A domain of unlabeled vertices.
UnlabeledVertex: GraphVertex with
    vertex: () -> %
      ++ vertex() creates a new vertex.
  == add
    Rep == ID
    id(x: %): ID == rep x -- local
    vertex(): % == per new()$ID
    hash(x: %): SingleInteger == hash id x
    latex(x: %): String == latex id x
    coerce(x: %): OutputForm == id(x)::OutputForm
    ((x: %) = (y: %)): Boolean == id x = id y
    smaller?(x: %, y: %): Boolean == id x < id y
@

<<domain LVERTEX LabeledVertex>>=
<<common>>
)abbrev domain LVERTEX LabeledVertex
++ Author: Ralf Hemmecke
++ Keywords: graph theory
++ Description:
++ A domain of labeled vertices.
LabeledVertex(L: SetCategory): Join(Labeled L, GraphVertex) with
    vertex: L -> %
      ++ vertex(l) returns a vertex with label l.
 == add
    Rep == Record(ident: ID, lab: L)
    id(x: %): ID == (rep x).ident -- local
    hash(x: %): SingleInteger == hash id x
    latex(x: %): String == latex label x
    coerce(x: %): OutputForm == label(x)::OutputForm
    ((x: %) = (y: %)): Boolean == id x = id y
    smaller?(x: %, y: %): Boolean == id x < id y
    vertex(l: L): % == per [new()$ID, l]
    label(x: %): L == (rep x).lab
@

<<domain UDEDGE UnlabeledDirectedEdge>>=
<<common>>
)abbrev domain UDEDGE UnlabeledDirectedEdge
++ Author: Ralf Hemmecke
++ Keywords: graph theory
++ Description:
++ A domain of directed unlabeled edges.
UnlabeledDirectedEdge(V: GraphVertex): _
  Join(Directed, GraphEdge V) with
    edge: (V, V) -> %
      ++ edge(v1, v2) returns an new edge from vertex v1 to vertex v2.
  == add
    Rep == Record(ident: ID, vert1: V, vert2: V)
    id(x: %): ID == (rep x).ident --local
    edge(v1: V, v2: V): % == per [new()$ID, v1, v2]
    vertex1(x: %): V == (rep x).vert1
    vertex2(x: %): V == (rep x).vert2
    coerce(x: %): OutputForm ==
      n: OutputForm := id(x)::OutputForm
      v1: OutputForm := (vertex1 x) :: OutputForm
      v2: OutputForm := (vertex2 x) :: OutputForm
      hconcat [n, ": "::OutputForm, rarrow(v1, v2)]
    hash(x: %): SingleInteger == hash id x
    latex(x: %): String ==
        concat [latex id x, ":", latex vertex1 x, "\to ", latex vertex2 x]
    ((x: %) = (y: %)): Boolean == id x = id y
    smaller?(x: %, y: %): Boolean == id x < id y

<<domain UUEDGE UnlabeledUndirectedEdge>>=
<<common>>
)abbrev domain UUEDGE UnlabeledUndirectedEdge
++ Author: Ralf Hemmecke
++ Keywords: graph theory
++ Description:
++ A domain of unlabeled undirected edges.
UnlabeledUndirectedEdge(V: GraphVertex): GraphEdge V with
    vertex1: % -> V
      ++ vertex1(x) returns the first vertex of an edge.
      ++ In case the edge is undirected, the following holds:
      ++ smaller?(vertex1 x, vertex2 x).
    vertex2: % -> V
      ++ vertex2(x) returns the second vertex of an edge.
      ++ In case the edge is undirected, the following holds:
      ++ smaller?(vertex1 x, vertex2 x).
    edge: (V, V) -> %
      ++ edge(v1, v2) returns an new edge from vertex v1 to vertex v2.
  == UnlabeledDirectedEdge V add
    Rep == UnlabeledDirectedEdge V
    edge(v1: V, v2: V): % ==
      -- We store the vertex with the smaller id as first node.
      per(if smaller?(v1, v2) then edge(v1, v2)$Rep else edge(v2, v1)$Rep)
@

<<domain LDEDGE LabeledDirectedEdge>>=
<<common>>
)abbrev domain LDEDGE LabeledDirectedEdge
++ Author: Ralf Hemmecke
++ Keywords: graph theory
++ Description:
++ A domain of labeled directed edges.
LabeledDirectedEdge(L: SetCategory, V: GraphVertex): _
  Join(Labeled L, Directed, GraphEdge V) with
    edge: (V, V, L) -> %
      ++ edge(v1, v2, l) returns a vertex with label l going between
      ++ the vertices v1 and v2.
  == add
    Rep == Record(ident: ID, vert1: V, vert2: V, lab: L)
    id(x: %): ID == (rep x).ident -- local
    edge(v1: V, v2: V, l: L): % == per [new()$ID, v1, v2, l]
    label(x: %): L == (rep x).lab
    vertex1(x: %): V == (rep x).vert1
    vertex2(x: %): V == (rep x).vert2
    hash(x: %): SingleInteger == hash id x
    coerce(x: %): OutputForm ==
      n: OutputForm := label(x)::OutputForm
      v1: OutputForm := (vertex1 x) :: OutputForm
      v2: OutputForm := (vertex2 x) :: OutputForm
      hconcat [n, ": "::OutputForm, rarrow(v1, v2)]
    latex(x: %): String ==
        concat [latex label x, ":", latex vertex1 x, "\to ", latex vertex2 x]
    ((x: %) = (y: %)): Boolean == id x = id y
    smaller?(x: %, y: %): Boolean == id x < id y
@

<<domain LUEDGE LabeledUndirectedEdge>>=
<<common>>
)abbrev domain LUEDGE LabeledUndirectedEdge
++ Author: Ralf Hemmecke
++ Keywords: graph theory
++ Description:
++ A domain of labeled undirected edges.
LabeledUndirectedEdge(L: SetCategory, V: GraphVertex): _
  Join(Labeled L, GraphEdge V) with
    vertex1: % -> V
      ++ vertex1(x) returns the first vertex of an edge.
      ++ In case the edge is undirected, the following holds:
      ++ smaller?(vertex1 x, vertex2 x).
    vertex2: % -> V
      ++ vertex2(x) returns the second vertex of an edge.
      ++ In case the edge is undirected, the following holds:
      ++ smaller?(vertex1 x, vertex2 x).
    edge: (V, V, L) -> %
      ++ edge(v1, v2, l) returns a vertex with label l going between
      ++ the vertices v1 and v2.
  == LabeledDirectedEdge(L, V) add
    Rep == LabeledDirectedEdge(L, V)
    edge(v1: V, v2: V, l: L): % ==
      -- We store the vertex with the smaller id as first node.
      per(if smaller?(v1, v2) then edge(v1, v2, l)$Rep else edge(v2, v1, l)$Rep)
@

<<domain GGRAPH GenericGraph>>=
<<common>>
)abbrev domain GGRAPH GenericGraph
++ Author: Ralf Hemmecke
++ Keywords: graph theory
++ Description:
++ A domain that represents an unlabeled graph.
GenericGraph(V: GraphVertex, E: GraphEdge V): _
  Join(FinGraph(V, E), GraphVertex) == add
    EDGES ==> List E -- for in/out-going edges
    INOUT ==> Record(outgoing: EDGES, ingoing: EDGES, xloops: EDGES)
        -- loops and in- and outgoing edges of a vertex
    VIO ==> Record(key: V, entry: INOUT) -- insert! into the Rep's hashtable
    HTVIO ==> HashTable(V, INOUT, "ID") -- hashtable of the Rep
    Rep == Record(ident: ID, hashtablevio: HTVIO)

    -- local functions
    id(x: %): ID == (rep x).ident
    htvio(x: %): HTVIO == (rep x).hashtablevio
    toVIO(v: V): VIO == [v, [[], [], []]$INOUT]$VIO
    getio(v: V, ht: HTVIO): INOUT ==
        -- get the entry for v in the hash table ht and create
        -- a new empty entry for v if not yet available
        uio: Union(INOUT, "failed") := search(v, ht)
        uio case "failed" => -- create new empty entry.
            vio: VIO := toVIO v
            ht := insert!(vio, ht)
            vio.entry
        uio :: INOUT
    insertNew(e: E, es: List E): List E ==
        -- insert e into  the list es if it is not already there
         if member?(e, es) then es else cons(e, es)
    insertEdge!(e: E, ht: HTVIO): HTVIO ==
        -- Destructvioely insert the edge e if it doesn't yet exist.
        -- If the edge id is already known, nothing is done.
        (v1, v2) := (vertex1 e, vertex2 e)
        io := getio(v1, ht)
        v1 = v2 => (io.xloops := insertNew(e, io.xloops); ht)
        io.outgoing := insertNew(e, io.outgoing)
        io := getio(v2, ht)
        io.ingoing  := insertNew(e, io.ingoing)
        ht
    removeEdge!(e: E, ht: HTVIO): HTVIO ==
        (v1, v2) := (vertex1 e, vertex2 e)
        io := getio(v1, ht);
        v1 = v2 => (io.xloops := remove!(e, io.xloops); ht)
        io.outgoing := remove!(e, io.outgoing)
        io := getio(v2, ht)
        io.ingoing  := remove!(e, io.ingoing)
        ht

    -- exported functions
    hash(x: %): SingleInteger == hash id x
    ((x: %) = (y: %)): Boolean == id x = id y
    smaller?(x: %, y: %): Boolean == id x < id y
    finiteGraph(vs: List V, es: List E): % ==
        -- We make sure that all the vertices of the edges also become
        -- vertices of the graph and that the vertices are stored in a
        -- list which is sorted by ascending id.
        ht: HTVIO := table()
        for v in vs repeat insert!(toVIO v, ht)$HTVIO
        for e in es repeat insertEdge!(e, ht)
        per [new()$ID, ht]

    insert!(v: V, x: %): % == (insert!(toVIO v, htvio x)$HTVIO; x)
    insert!(e: E, x: %): % == (insertEdge!(e, htvio x); x)
    remove!(v: V, x: %): % ==
        -- We also remove all edges that are connected to vertex v.
        ht: HTVIO := htvio x
        uio: Union(INOUT, "failed") := search(v, ht)
        uio case "failed" => x -- do nothing if vertex is not in the graph
        io: INOUT := uio::INOUT
        -- remove all outgoing edges of v
        for e in io.outgoing repeat
            io2: INOUT := ht vertex2 e -- other vertex (it exists!)
            io2.ingoing := remove!(e, io2.ingoing) -- remove ingoing of v2
        -- remove all ingoing edges
        for e in io.ingoing repeat
            io1: INOUT := ht vertex1 e -- other vertex (it exists!)
            io1.outgoing := remove!(e, io1.outgoing) -- remove outgoing of v1
        remove!(v, ht)$HTVIO -- remove the vertex entry itself
        x
    remove!(e: E, x: %): % == (removeEdge!(e, htvio x); x)
    vertices(x: %): List V == keys htvio x
    edges(x: %): List E ==
        le: List E := []
        -- It's enough to collect the loops and the outgoing edges for
        -- each vertex.
        for io in entries htvio x repeat
            for e in io.xloops repeat le := cons(e, le)
            for e in io.outgoing repeat le := cons(e, le)
        le
    member?(x: %): V -> Boolean == (v: V): Boolean +-> key?(v, htvio x)
    degree(x: %): V -> Z == (v: V): Z +->
        uio: Union(INOUT, "failed") := search(v, htvio x)
        uio case "failed" => -1
        io: INOUT := uio :: INOUT
        2 * #(io.xloops)::Z + #(io.ingoing)::Z + #(io.outgoing)::Z
    edges(x: %): V -> List E == (v: V): List E +->
        io: INOUT := qelt(htvio x, v)
        le: List E := concat(io.ingoing, io.outgoing)
        for e in io.xloops repeat le := cons(e, le)
        le
    loops(x: %): V -> List E == (v: V): List E +-> qelt(htvio x, v).xloops
    inDegree(x: %): V -> Z == (v: V): Z +->
        uio: Union(INOUT, "failed") := search(v, htvio x)
        uio case "failed" => -1
        io: INOUT := uio :: INOUT
        #(io.xloops)::Z + #(io.ingoing)::Z
    outDegree(x: %): V -> Z == (v: V): Z +->
        uio: Union(INOUT, "failed") := search(v, htvio x)
        uio case "failed" => -1
        io: INOUT := uio :: INOUT
        #(io.xloops)::Z + #(io.outgoing)::Z
    ingoingEdges(x: %): V -> List E == (v: V): List E +->
        qelt(htvio x, v).ingoing
    outgoingEdges(x: %): V -> List E == (v: V): List E +->
        qelt(htvio x, v).outgoing
    adjacencyAux(x: %): (V, V) -> N == (v1: V, v2: V): N +->
        io: INOUT := qelt(htvio x, v1)
        v1=v2 => #(io.xloops)
        n: N := 0
        for e in io.outgoing repeat if vertex2(e)=v2 then n := n+1
        n
    if E has Directed then
        adjacency(x: %): (V, V) -> N == (v1: V, v2: V): N +->
            adjacencyAux(x)(v1, v2)
    else -- not(E has Directed)
        adjacency(x: %): (V, V) -> N == (v1: V, v2: V): N +->
            smaller?(v1, v2) => adjacencyAux(x)(v1, v2)
            adjacencyAux(x)(v2, v1)
@
