-- These two macros are necessary to distinguish between Rep and %.
rep x ==> (x@%) pretend Rep
per x ==> (x@Rep) pretend %
-------------------------------------------------------------------

ID ==> Symbol
-- Each vertex and each edge gets a unique id.

)abbrev category GRVERT GraphVertex
++ Author: Ralf Hemmecke
++ Keywords: graph theory
++ Description:
++ Category for vertices of a graph.
GraphVertex: Category == SetCategory with
    id: % -> ID
      ++ id(x) returns the id of the edge x.
  add
    hash(x: %): SingleInteger == hash id x
    latex(x: %): String == latex id x
    ((x: %) = (y: %)): Boolean == id x = id y
    coerce(x: %): OutputForm == id(x)::OutputForm

)abbrev category GREDGE GraphEdge
++ Author: Ralf Hemmecke
++ Keywords: graph theory
++ Description:
++ Category for edges of a graph. Edges are supposed to be connected
++ to two vertices.
GraphEdge(V: GraphVertex): Category == SetCategory with
    id: % -> ID
      ++ id() returns the id of the edge
    vertex1: % -> V
      ++ vertex1(x) returns the first vertex of an edge.
      ++ In case the edge is undirected, the following holds:
      ++ id vertex1 x < id vertex2 x.
    vertex2: % -> V
      ++ vertex2(x) returns the second vertex of an edge.
      ++ In case the edge is undirected, the following holds:
      ++ id vertex1 x < id vertex2 x.
  add
    hash(x: %): SingleInteger == hash id x
    latex(x: %): String == latex id x
    ((x: %) = (y: %)): Boolean == id x = id y
    coerce(x: %): OutputForm == id(x)::OutputForm

)abbrev category FGRAPH FinGraph
++ Author: Ralf Hemmecke
++ Keywords: graph theory
++ Description:
++ Category of finite graphs, allows us to model graph theory
FinGraph(V: GraphVertex, E: GraphEdge V): Category == SetCategory with
    finiteGraph: (List V, List E) -> %
      ++ finiteGraph(vertices, edgees) constructs a graph made
      ++ from vertices and edges.
    insert!: (V, %) -> %
      ++ insert!(v, x) adds a new vertex v to the graph x.
      ++ The function works destructively on x.
    insert!: (E, %) -> %
      ++ insert!(e, x) adds a new edge e and to the graph x
      ++ (including its vertices).
      ++ The function works destructively on x.
    remove!: (V, %) -> %
      ++ remove!(v, x) removes the vertex v and all edges that
      ++ contain v from the graph x.
      ++ The function works destructively on x.
    remove!: (E, %) -> %
      ++ remove!(e, x) removes the edge e from the graph x.
      ++ The function works destructively on x.
    vertices: % -> List V
      ++ vertices(x) returns all vertices of the graph x.
    edges: % -> List E
      ++ edges(x) returns all edges of the graph x.
  add
    ((x: %) = (y: %)): Boolean ==
        -- dummy implementation
        -- We assume the list of vertices and edges are sorted by their
        -- respective id's.
        (vsx, vsy) := (vertices x, vertices y)
        #vsx ~= #vsy => false
        for vx in vsx for vy in vsy repeat if vx ~= vy then return false
        (esx, esy) := (edges x, edges y)
        #esx ~= #esy => false
        for ex in esx for ey in esy repeat if ex ~= ey then return false
        true
    coerce(x: %): OutputForm ==
        vs: List OutputForm := [v::OutputForm for v in vertices x]
        es: List OutputForm := [e::OutputForm for e in edges x]
        bracket [bracket vs, bracket es]

)abbrev category LABELED Labeled
++ Author: Ralf Hemmecke
++ Description:
++ Category for labeled objects.
++ The category Labeled mainly serves as an attribute category.
Labeled(L: SetCategory): Category == with
    label: % -> L
      ++ label(x) returns the label corresponding to x.

)abbrev category DIRECT Directed
++ Author: Ralf Hemmecke
++ Description:
++ Category for directed objects.
++ The category Directed only serves as an attribute category.
Directed(): Category == with ()

)abbrev domain UVERTEX UnlabeledVertex
++ Author: Ralf Hemmecke
++ Keywords: graph theory
++ Description:
++ A domain of unlabeled vertices.
UnlabeledVertex: GraphVertex with
    vertex: () -> %
      ++ vertex() creates a new vertex.
  == add
    Rep == ID
    vertex(): % == per new()$ID
    id(x: %): ID == rep x

)abbrev domain LVERTEX LabeledVertex
++ Author: Ralf Hemmecke
++ Keywords: graph theory
++ Description:
++ A domain of labeled vertices.
LabeledVertex(L: SetCategory): Join(Labeled L, GraphVertex) with
    vertex: L -> %
      ++ vertex(l) returns a vertex with label l.
 == add
    Rep == Record(ident: ID, lab: L)
    vertex(l: L): % == per [new()$ID, l]
    id(x: %): ID == (rep x).ident
    label(x: %): L == (rep x).lab
    coerce(x: %): OutputForm == label(x)::OutputForm

)abbrev domain UDEDGE UnlabeledDirectedEdge
++ Author: Ralf Hemmecke
++ Keywords: graph theory
++ Description:
++ A domain of directed unlabeled edges.
UnlabeledDirectedEdge(V: GraphVertex): Join(Directed, GraphEdge V) with
    edge: (V, V) -> %
      ++ edge(v1, v2) returns an new edge from vertex v1 to vertex v2.
  == add
    Rep == Record(ident: ID, vert1: V, vert2: V)
    edge(v1: V, v2: V): % == per [new()$ID, v1, v2]
    id(x: %): ID == (rep x).ident
    vertex1(x: %): V == (rep x).vert1
    vertex2(x: %): V == (rep x).vert2
    coerce(x: %): OutputForm ==
      n: OutputForm := id(x)::OutputForm
      v1: OutputForm := (vertex1 x) :: OutputForm
      v2: OutputForm := (vertex2 x) :: OutputForm
      hconcat [n, ": "::OutputForm, v1, " --> "::OutputForm, v2]

)abbrev domain UUEDGE UnlabeledUndirectedEdge
++ Author: Ralf Hemmecke
++ Keywords: graph theory
++ Description:
++ A domain of unlabeled undirected edges.
UnlabeledUndirectedEdge(V: GraphVertex): GraphEdge V with
    edge: (V, V) -> %
      ++ edge(v1, v2) returns an new edge from vertex v1 to vertex v2.
  == UnlabeledDirectedEdge V add
    Rep == UnlabeledDirectedEdge V
    edge(v1: V, v2: V): % ==
      -- We store the vertex with the smaller id as first node.
      i: ID := new()$ID
      per(if id v1 < id v2 then edge(v1, v2)$Rep else edge(v2, v1)$Rep)
    coerce(x: %): OutputForm ==
      n: OutputForm := id(x)::OutputForm
      v1: OutputForm := (vertex1 x) :: OutputForm
      v2: OutputForm := (vertex2 x) :: OutputForm
      hconcat [n, ": "::OutputForm, v1, " --- "::OutputForm, v2]

)abbrev domain LDEDGE LabeledDirectedEdge
++ Author: Ralf Hemmecke
++ Keywords: graph theory
++ Description:
++ A domain of labeled directed edges.
LabeledDirectedEdge(L: SetCategory, V: GraphVertex): _
  Join(Labeled L, Directed, GraphEdge V) with
    edge: (L, V, V) -> %
      ++ edge(l, v1, v2) returns a vertex with label l going between
      ++ the vertices v1 and v2.
  == add
    Rep == Record(ident: ID, lab: L, vert1: V, vert2: V)
    edge(l: L, v1: V, v2: V): % == per [new()$ID, l, v1, v2]
    id(x: %): ID == (rep x).ident
    label(x: %): L == (rep x).lab
    vertex1(x: %): V == (rep x).vert1
    vertex2(x: %): V == (rep x).vert2
    coerce(x: %): OutputForm ==
      n: OutputForm := label(x)::OutputForm
      v1: OutputForm := (vertex1 x) :: OutputForm
      v2: OutputForm := (vertex2 x) :: OutputForm
      hconcat [n, ": "::OutputForm, v1, " --> "::OutputForm, v2]

)abbrev domain LUEDGE LabeledUndirectedEdge
++ Author: Ralf Hemmecke
++ Keywords: graph theory
++ Description:
++ A domain of labeled undirected edges.
LabeledUndirectedEdge(L: SetCategory, V: GraphVertex): _
  Join(Labeled L, GraphEdge V) with
    edge: (L, V, V) -> %
      ++ edge(l, v1, v2) returns a vertex with label l going between
      ++ the vertices v1 and v2.
  == LabeledDirectedEdge(L, V) add
    Rep == LabeledDirectedEdge(L, V)
    edge(l: L, v1: V, v2: V): % ==
      -- We store the vertex with the smaller id as first node.
      per(if id v1 < id v2 then edge(l, v1, v2)$Rep else edge(l, v2, v1)$Rep)
    coerce(x: %): OutputForm ==
      n: OutputForm := label(x)::OutputForm
      v1: OutputForm := (vertex1 x) :: OutputForm
      v2: OutputForm := (vertex2 x) :: OutputForm
      hconcat [n, ": "::OutputForm, v1, " --- "::OutputForm, v2]

)abbrev domain GGRAPH GenericGraph
++ Author: Ralf Hemmecke
++ Keywords: graph theory
++ Description:
++ A domain that represents an unlabeled graph.
GenericGraph(V: GraphVertex, E: GraphEdge V): _
  Join(FinGraph(V, E), GraphVertex) == add
    HTE ==> HashTable(ID, E, "ID") -- for in/out-going edges
    VIO ==> Record(vert: V, ingoing: HTE, outgoing: HTE)
        -- vertices with their in- and outgoing edges
    IV ==> Record(key: ID, entry: VIO) -- insert! into the Rep's hashtable
    HTVIO ==> HashTable(ID, VIO, "ID") -- hashtable of the Rep
    Rep == Record(ident: ID, htvio: HTVIO)

    -- local functions
    toIV(v: V): IV == [id v, [v, table(), table()]$VIO]$IV
    getvio(v: V, ht: HTVIO): VIO ==
        -- get the entry for v in the hash table ht and create
        -- a new empty entry for v if not yet available
        uvio: Union(VIO, "failed") := search(id v, ht)
        uvio case "failed" => -- create new empty entry.
            iv: IV := toIV v
            ht := insert!(iv, ht)
            iv.entry
        uvio :: VIO
    insertDirectedEdge!(e: E, h: HTE): Void ==
        -- Destructively insert the edge e into the hash table h
        -- if it doesn't yet exist. If the edge id is already known,
        -- nothing is done.
        i := id e
        ue: Union(E, "failed") := search(i, h)
        ue case "failed" => insert!([i, e]$Record(key:ID,entry:E), h)
    insertEdge!(e: E, ht: HTVIO): Void ==
        insertDirectedEdge!(e, getvio(vertex1 e, ht).outgoing)
        insertDirectedEdge!(e, getvio(vertex2 e, ht).ingoing)
    removeEdge!(e: E, ht: HTVIO): HTVIO ==
        remove!(id e, getvio(vertex1 e, ht).outgoing)$HTE
        remove!(id e, getvio(vertex2 e, ht).ingoing)$HTE
        ht

    -- exported functions
    finiteGraph(vs: List V, es: List E): % ==
        -- We make sure that all the vertices of the edges also become
        -- vertices of the graph and that the vertices are stored in a
        -- list which is sorted by ascending id.
        ht: HTVIO := table()
        for v in vs repeat insert!(toIV v, ht)$HTVIO
        for e in es repeat insertEdge!(e, ht)
        per [new()$ID, ht]

    insert!(v: V, x: %): % == (insert!(toIV v, (rep x).htvio)$HTVIO; x)
    insert!(e: E, x: %): % == (insertEdge!(e, (rep x).htvio); x)
    remove!(v: V, x: %): % ==
        -- We also remove all edges that are connected to vertex v.
        ht: HTVIO := (rep x).htvio
        i: ID := id v
        uvio: Union(VIO, "failed") := search(i, ht)
        uvio case "failed" => x -- do nothing if vertex is not in the graph
        vio: VIO := uvio::VIO
        -- remove all outgoing edges of v
        h: HTE := vio.outgoing
        for e in entries h repeat
            vio2: VIO := ht id vertex2 e -- other vertex (it exists!)
            remove!(id e, vio2.ingoing) -- remove ingoing of v2
        -- remove all ingoing edges
        h := vio.ingoing
        for e in entries h repeat
            vio1: VIO := ht id vertex1 e -- other vertex (it exists!)
            remove!(id e, vio1.outgoing) -- remove outgoing of v1
        remove!(i, ht)$HTVIO -- remove the vertex entry itself
        x
    remove!(e: E, x: %): % == (removeEdge!(e, (rep x).htvio); x)
    vertices(x: %): List V == [vio.vert for vio in entries((rep x).htvio)]
    edges(x: %): List E ==
        le: List E := []
        for vio in entries((rep x).htvio) repeat
            le := concat!(entries(vio.outgoing), le)
        le
    id(x: %): ID == (rep x).ident
