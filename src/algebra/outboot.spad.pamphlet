\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/algebra outboot.spad}
\author{Ralf Hemmecke}
\maketitle
\begin{abstract}
Translation of src/interp/i-output.boot to spad.
\end{abstract}
\eject
\tableofcontents
\eject
\section{About this module}

<<package OUTTRAN OutTransformation>>=
)abbrev package OUTTRAN OutputTransformation
OutputTransformation: with
    outputTran: OutputForm -> OutputForm
  == add
    import from OutputFormTools

    DBGPRINT(x: None): Void == (PRINC(x)$Lisp; TERPRI()$Lisp)
    dbgPrint x ==> NIL -- DBGPRINT(x pretend None)

    OF ==> OutputForm
    SEX ==> SExpression
    asSEX z ==> z pretend SEX
    asOF z ==> z pretend OF
    toOF z ==> z::OF
    sy z ==> z::Symbol
    sx z ==> outputForm sy z

    -- obj2String o ==
    --   atom o =>
    --     STRINGP o => o
    --     o = " " => '" "
    --     o = ")" => '")"
    --     o = "(" => '"("
    --     STRINGIMAGE o
    --   concatenateStringList([obj2String o' for o' in o])
    obj2String(o: OF): String ==
        atom? o =>
          string? o => string o
          o = sx " " => " "
          o = sx "(" => "("
          o = sx ")" => ")"
          (STRINGIMAGE$Lisp o) pretend String
        concat(obj2String operator o,
               concat [obj2String z for z in arguments o])

    -- The next two functions are designed to replace successive instances of
    -- binary functions with the n-ary equivalent, cutting down on recursion
    -- in outputTran and in particular allowing big polynomials to be printed
    -- without stack overflow.  MCD.
    -- flattenOps l ==
    --   [op, :args ] := l
    --   op in ['"+",'"*","+","*"] =>
    --     [op,:checkArgs(op,args)]
    --   l
    -- checkArgs(op,tail) ==
    --   head := []
    --   while tail repeat
    --     term := first tail
    --     atom term =>
    --       head := [term,:head]
    --       tail := rest tail
    --     not LISTP term => -- never happens?
    --       head := [term,:head]
    --       tail := rest tail
    --     op=first term =>
    --       tail := [:rest term,:rest tail]
    --     head := [term,:head]
    --     tail := rest tail
    --   REVERSE head
    checkArgs(op: OF, tail: List OF): List OF ==
      dbgPrint("rhxcheckArgs")
      dbgPrint(op)
      dbgPrint(tail)
      head: List OF := empty()
      while not empty? tail repeat
        term: OF := first tail
        tail := rest tail
        (not atom? term) and op = operator term =>
          tail := concat(arguments term, tail)
        head := cons(term, head)
      dbgPrint(head)
      reverse! head

    flattenOps(op: OF, args: List OF): List OF ==
      dbgPrint("rhxflattenOps")
      dbgPrint(l)
      ops: List OF := [sx "+", sx "*", asOF "+", asOF "*"]
      member?(op, ops) =>
        dbgPrint("rhxflattenOps member")
        checkArgs(op, args)
      args

    outputTran(x: OutputForm): OutputForm ==
      dbgPrint("rhxoutputTran")
      dbgPrint(x)

      string? x => x

      --rhx: Maybe VECP(x)=true is not a case in OutputForm
      VECP(x)$Lisp => BREAK()$Lisp

      --rhx: There are only integers in OutputForm.
      -- NUMBERP x =>
      --   MINUSP x => ["-",MINUS x]
      --   x
      integer? x =>
        dbgPrint("rhxoutputTran int")
        integer x < 0 =>
          dbgPrint("rhxoutputTran -int")
          - toOF(- integer x)
        x

      float? asSEX x => BREAK()$Lisp -- floats are strings in OutputForm

      atom? x =>
        dbgPrint("rhxoutputTran atom")
        asSEX x = _$EmptyMode$Lisp => asOF specialChar$Lisp 'quad
        x

      -- assert(list? sex)
      op: OF := operator x
      l: List OF := arguments x
      n: NonNegativeInteger := #l

      --x is [c,var,mode] and c in '(_pretend _: _:_: _@) =>
      --  var := outputTran var
      --  if PAIRP var then var := ['PAREN,var]
      --  ['CONCATB,var,c,obj2String prefix2String mode]
      n=2 and member?(op, [sx "pretend", sx ":", sx "::", sx "@"]) =>
        dbgPrint("rhxoutputTran ::")
        var: OF := outputTran first l
        mode: OF := asOF obj2String asOF prefix2String$Lisp second l
        if pair? asSEX var then var := paren var
        blankSeparate [var, op, mode]

      -- x is ['ADEF,vars,.,.,body] =>
      --   vars :=
      --       vars is [x] => x
      --       ['Tuple,:vars]
      --   outputTran ["+->", vars, body]
      op = sx "ADEF" and n=4 =>
        dbgPrint("rhxoutputTran ADEF")
        vars: OF := first l
        body: OF := third rest l
        vl: List OF := list vars
        vars := if #vl=1 then first vl else outputForm(sx "Tuple", vl)
        outputTran outputForm(sx "+->", [vars, body])

      -- x is ['MATRIX,:m] => outputTranMatrix m
      op = sx "MATRIX" => outputTranMatrix$Lisp l

      -- x is ['matrix,['construct,c]] and
      --   c is ['COLLECT,:m,d] and d is ['construct,e] and e is ['COLLECT,:.] =>
      --     outputTran ['COLLECT,:m,e]
      if op = sx "matrix" and n=1 and not atom?(l.1) then
        dbgPrint("rhxoutputTran matrix")
        op1: OF := operator(l.1)
        l1: List OF := arguments(l.1)
        if #l1 = 1 and op1 = sx "construct" and not atom?(l1.1) then
          c: List OF := arguments(l1.1)
          if #c>0 and operator(l1.1) = sx "COLLECT" then
            dm: List OF := reverse c
            d: OF := first dm
            if not atom? d and # list d = 2 then
              m: List OF := rest dm
              if operator d = sx "construct" and _
                 not atom?(e: OF := first arguments d) then
                if operator e = sx "COLLECT" then
                  return outputTran outputForm(sx "COLLECT", reverse cons(e, m))

      -- x is ['LIST,:l] => outputTran ['BRACKET,['AGGLST,:l]]
      -- x is ['construct,:l] =>
      --   ['BRACKET,['AGGLST,:[outputTran y for y in l]]]
      op = sx "LIST" or op = sx "construct" =>
        dbgPrint("rhxoutputTran LIST/construct")
        bracket commaSeparate [outputTran z for z in l]

      -- x is ['SPADMAP, :l] => outputMapTran l
      op = sx "SPADMAP" =>
        dbgPrint("rhxoutputTran SPADMAP")
        asOF((outputMapTran$Lisp)(l))

      -- x is ['brace, :l]    =>
      --   ['BRACE,  ['AGGLST,:[outputTran y for y in l]]]
      op = sx "brace" =>
        dbgPrint("rhxoutputTran brace")
        brace commaSeparate [outputTran z for z in l]

      -- x is ["return", l] => ["return", outputTran l]
      op = sx "return" and n=1 =>
        dbgPrint("rhxoutputTran return=1")
        outputForm(asOF "return", [outputTran first l])

      -- x is ["return", ., :l] => ["return", :outputTran l]
      op = sx "return" and n>1 =>
        dbgPrint("rhxoutputTran return>1")
        outputForm(asOF "return", list outputTran asOF rest l)

      -- x is [["$elt",domain,"float"], x, y, z] and (domain = $DoubleFloat or
      --   domain is ['Float]) and INTEGERP x and INTEGERP y and INTEGERP z and
      --       z > 0  and (float := getFunctionFromDomain("float",domain,[$Integer,$Integer,$PositiveInteger])) =>
      --           f := SPADCALL(x,y,z,float)
      --           o := coerceInteractive(mkObjWrap(f, domain), '(OutputForm))
      --           objValUnwrap o
      --rhx: I hope that's a proper translation into SPAD.
      if n=3 and not atom? op and _
          #arguments op=2 and operator op = sx "$elt" and _
          second arguments op = sx "float" then
        dbgPrint("rhxoutputTran $elt")
        domain: OF := first arguments op
        xx: OF := l.1
        yy: OF := l.2
        zz: OF := l.3
        pi x ==> (integer x)::PositiveInteger
        if integer? xx and integer? yy and integer? zz and (integer zz > 0) then
          if domain = asOF(_$DoubleFloat$Lisp) then
            return toOF(float(integer xx, integer yy, pi zz)$DoubleFloat)
           else if not atom? domain and operator domain = sx "Float" then
            return toOF(float(integer xx, integer yy, pi zz)$Float)

      -- [op,:l]:= flattenOps x
      dbgPrint("rhxoutputTran1")
      l := flattenOps(op, l)
      dbgPrint("rhyoutputTran2")
      dbgPrint(op)
      dbgPrint(l)
      n := #l

      -- Note that x is still unflattened. We shouldn't use it anymore
      -- from here on.

      -- --needed since "op" is string in some spad code
      -- if STRINGP op then (op := INTERN op; x:= [op,:l])
      if string? op then op := sx string op

      -- op = 'LAMBDA_-CLOSURE => 'Closure
      op = sx "LAMBDA-CLOSURE" =>
        dbgPrint("rhxoutputTran closure")
        sx "Closure"

      -- x is ['break,:.] => 'break
      op = sx "break" =>
        dbgPrint("rhxoutputTran break")
        sx "break"

      -- x is ['SEGMENT,a] =>
      --   a' := outputTran a
      --   if LISTP a' then a' := ['PAREN,a']
      --   ['SEGMENT,a']
      -- x is ['SEGMENT,a,b] =>
      --   a' := outputTran a
      --   b' := outputTran b
      --   if LISTP a' then a' := ['PAREN,a']
      --   if LISTP b' then b' := ['PAREN,b']
      --   ['SEGMENT,a',b']
      op = sx "SEGMENT" and (n=1 or n=2) =>
        dbgPrint("rhxoutputTran SEGMENT")
        a: OF := outputTran first l
        if not atom? a then a := paren a
        n = 1 => SEGMENT(a)
        b: OF := outputTran second l
        if not atom? b then b := paren b
        SEGMENT(a, b)

      -- op is ["$elt",targ,fun] or not $InteractiveMode and op is ["elt",targ,fun] =>
      --   -- l has the args
      --   targ' := obj2String prefix2String targ
      --   if 2 = #targ then targ' := ['PAREN,targ']
      --   ['CONCAT,outputTran [fun,:l],'"$",targ']
      if not atom? op and #(args: List OF := arguments op) = 2 then
        op2: OF := operator op
        targ: OF := first args
        fun: OF := second args
        dbgPrint("rhxoutputTran if elt")
        (op2 = sx "$elt" or _
         (op2 = sx "elt" and not(_$InteractiveMode$Lisp pretend Boolean))) =>
          dbgPrint("rhxoutputTran elt")
          targ2: OF := asOF obj2String asOF prefix2String$Lisp targ
          if # list targ = 2 then targ2 := paren targ2
          a := outputTran outputForm(fun, l)
          outputForm(sx "CONCAT", [a, asOF "$", targ2])

      -- x is ["$elt",targ,c] or not $InteractiveMode and x is ["elt",targ,c] =>
      --   targ' := obj2String prefix2String targ
      --   if 2 = #targ then targ' := ['PAREN,targ']
      --   ['CONCAT,outputTran c,'"$",targ']
      n=2 and (op = sx "$elt" or
       (op = sx "elt" and not(_$InteractiveMode$Lisp pretend Boolean))) =>
        dbgPrint("rhxoutputTran elt2")
        targ2: OF := asOF obj2String asOF prefix2String$Lisp first l
        if # list first l = 2 then targ2 := paren targ2
        outputForm(sx "CONCAT", [outputTran second l, asOF "$", targ2])

      -- x is ["-",a,b] =>
      --   a := outputTran a
      --   b := outputTran b
      --   INTEGERP b =>
      --     b < 0 => ["+",a,-b]
      --     ["+",a,["-",b]]
      --   b is ["-",c] => ["+",a,c]
      --   ["+",a,["-",b]]
      op = sx "-" and n=2 =>
        dbgPrint("rhxoutputTran -")
        a := outputTran first l
        b := outputTran second l
        integer? b =>
          integer b < 0 => a + (- toOF integer b)
          a + (- b)
        not atom? b and #(arguments b) = 1 and operator b = sx "-" =>
          a + first arguments b
        a + (- b)

      --rhx: Just call the boot function for non-algebraic stuff.
      -- op = 'IF       => outputTranIf x
      -- op = 'COLLECT  => outputTranCollect x
      -- op = 'REDUCE   => outputTranReduce x
      -- op = 'REPEAT   => outputTranRepeat x
      -- op = 'SEQ      => outputTranSEQ x
      -- op in '(cons nconc) => outputConstructTran x
      op = sx "IF"      => outputTranIf$Lisp x
      op = sx "COLLECT" => outputTranCollect$Lisp x
      op = sx "REDUCE"  => outputTranReduce$Lisp x
      op = sx "REPEAT"  => outputTranRepeat$Lisp x
      op = sx "SEQ"     => outputTranSEQ$Lisp x
      op = sx "cons" or op = sx "nconc" => outputConstructTran$Lisp x

      -- l:= [outputTran y for y in l]
      dbgPrint("rhxoutputTran3")
      l := [outputTran z for z in l]
      dbgPrint("rhxoutputTran4")
      dbgPrint(l)

      -- op = "*" =>
      --    l is [a] => outputTran a
      --    l is [["-",a],:b] =>
      --      -- now this is tricky because we've already outputTran the list
      --      -- expect trouble when outputTran hits b again
      --      -- some things object to being outputTran twice ,e.g.matrices
      --      -- same thing a bit lower down for "/"
      --      a=1 => outputTran ["-",[op,:b]]
      --      outputTran ["-",[op,a,:b]]
      --    [op,:"append"/[(ss is ["*",:ll] => ll; [ss]) for ss in l]]
      op = sx "*" =>
        dbgPrint("rhxoutputTran *")
        a := first l
        n = 1 =>
          dbgPrint("rhxoutputTran *=1")
          outputTran a
        n > 1 and not atom? a and #(arguments a) = 1 and operator a = sx "-" =>
          dbgPrint("rhxoutputTran *>1")
          a := first arguments a
          integer? a and integer a = 1 =>
            dbgPrint("rhxoutputTran *>1 a=1")
            outputTran(- outputForm(op, rest l))
          dbgPrint("rhxoutputTran *>1 - before *")
          outputTran(- outputForm(op, cons(a, rest l)))
        --rhx: That is basically flattenOps. But it has been done before.
        dbgPrint("rhxoutputTran * checkArgs")
        outputForm(op, checkArgs(op, l))

      dbgPrint("rhxoutputTran5")

      -- op = "+" =>
      --    l is [a] => outputTran a
      --    [op,:"append"/[(ss is ["+",:ll] => ll; [ss]) for ss in l]]
      op = sx "+" =>
        dbgPrint("rhxoutputTran +")
        n = 1 => outputTran first l
        --rhx: That is basically flattenOps. But it has been done before.
        outputForm(op, checkArgs(op, l))

      -- op = "/" =>
      --   $fractionDisplayType = 'horizontal =>
      --       op := 'SLASH
      --       l is [a, b] =>
      --           a :=
      --                ATOM(a) => a
      --                ['PAREN, a]
      --           b :=
      --                ATOM(b) => b
      --                ['PAREN, b]
      --           [outputTran op, a, b]
      --       BREAK()
      --   op := 'OVER
      --   l is [["-",a],:b] => outputTran ["-",[op,a,:b]]
      --   [outputTran op,:l]
      op = sx "/" =>
        dbgPrint("rhxoutputTran /")
        asOF(_$fractionDisplayType$Lisp) = sx "horizontal" =>
          op := sx "SLASH"
          n = 2 =>
            a := if atom?(l.1) then l.1 else paren(l.1)
            b := if atom?(l.2) then l.2 else paren(l.2)
            --rhx: Why again outputTran on op='SLASH?
            outputForm(op, [a, b])
          BREAK()$Lisp
        op := sx "OVER"
        n > 1 and not atom?(l.1) and operator(l.1) = sx "-" =>
          outputTran(- outputForm(op, cons(first arguments(l.1), rest l)))
        --rhx: why outputTran on op='/?
        outputForm(op, l)

      -- op="|" and l is [["Tuple",:u],pred] =>
      --   ['PAREN,["|",['AGGLST,:l],pred]]
      --rhx: Why AGGLST l? That includes pred. Strange.
      op = sx "|" and n=2 and not atom?(l.1) and operator(l.1) = sx "Tuple" =>
        dbgPrint("rhxoutputTran |")
        paren outputForm(op, [commaSeparate l, l.2])

      -- op='Tuple  => ['PAREN,['AGGLST,:l]]
      op = sx "Tuple" =>
        dbgPrint("rhxoutputTran Tuple")
        paren l

      -- op='LISTOF => ['AGGLST,:l]
      op = sx "LISTOF" =>
        dbgPrint("rhxoutputTran LISTOF")
        commaSeparate l

      -- IDENTP op and not (op in '(_* _*_*) ) and char("*") = (PNAME op).0 =>
      --   mkSuperSub(op,l)
      --rhx: I'm not sure with the index after PNAME.
      import from Character
      symbol? op and not member?(op, [sx "*", sx "**"]) _
                 and char "*" = ((PNAME$Lisp)(op) pretend String).1 =>
        dbgPrint("rhxoutputTran symbol op")
        asOF mkSuperSub(op, l)$Lisp

      dbgPrint("rhxoutputTran before end")
      -- [outputTran op,:l]
      outputForm(outputTran op, l)
@

\section{License}
<<license>>=
--Copyright (c) 1991-2002, The Numerical ALgorithms Group Ltd.
--All rights reserved.
--
--Redistribution and use in source and binary forms, with or without
--modification, are permitted provided that the following conditions are
--met:
--
--    - Redistributions of source code must retain the above copyright
--      notice, this list of conditions and the following disclaimer.
--
--    - Redistributions in binary form must reproduce the above copyright
--      notice, this list of conditions and the following disclaimer in
--      the documentation and/or other materials provided with the
--      distribution.
--
--    - Neither the name of The Numerical ALgorithms Group Ltd. nor the
--      names of its contributors may be used to endorse or promote products
--      derived from this software without specific prior written permission.
--
--THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
--IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
--TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
--PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
--OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
--EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
--PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
--PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
--LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
--NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
--SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@

<<*>>=
<<license>>
<<package OUTTRAN OutputTransformation>>
@
\eject
\end{document}
