<<common>>=
-- These two macros are necessary to distinguish between Rep and %.
rep x ==> (x@%) pretend Rep
per x ==> (x@Rep) pretend %
-------------------------------------------------------------------
N ==> NonNegativeInteger
Z ==> Integer
@


<<domain XHASHTBL XHashTable>>=
<<common>>
)abbrev domain XHASHTBL XHashTable
++ Author: Ralf Hemmecke
++ Keywords: graph theory
++ Description:
++ An implementation of a hashtable that uses equality of the key domain
++ to decide upon equality of keys.
XHashTable(Key: SetCategory, Entry: SetCategory):
  Join(TableAggregate(Key, Entry), finiteAggregate, shallowlyMutable) == add
    KE ==> Record(key: Key, entry: Entry)

    -- Want hash function be part of the structure and want to be able
    -- to give a hash function at table creation.
    Rep == Record(numOfEntries: N, arr: FlexibleArray FlexibleArray KE)
    --local
    -- search(k, x) returns (h, i) where h is the hash of k and
    -- if k is in x, then (h, i) is its position in the structure,
    -- if k is not in x then i=0.
    localsearch(k: Key, x: %): Record(idx: N, bidx: N) ==
        -- search k in array
        a := rep(x).arr
        n: N := #a
        h: N := ((hash(k)::Z::N) rem n)+1                     -- Call hash$Key
        bucket := a.h
        for i in 1..#bucket repeat if bucket.i.key = k then return [h, i]
        [h, 0]
    -- Create a new array where each entry is an empty array, but at
    -- a different memory location.
    newArr(n: N): FlexibleArray FlexibleArray KE ==
       a: FlexibleArray FlexibleArray KE := new(n, empty())
       for i in 2..n repeat a.i := empty()
       a
    -- If the load factor has been reached the number of buckets is
    -- doubled.
    grow!(x: %): Void ==
        a := rep(x).arr
        n: N := #a
        m: N := 2*n
        c: FlexibleArray FlexibleArray KE := newArr m
        for i in 1..n repeat
            bucket := a.i
            for j in 1..#bucket repeat
                h: N := ((hash(bucket.j.key)::Z::N) rem m)+1  -- Call hash$Key
                concat!(c.h, bucket.j)
        rep(x).arr := c  --destructively set new array

    --exported

    -- We want the hash function as a parameter!
    -- table(hashfunction: Key -> SingleInteger): % ==
    -- empty(): % == table(hash$Key)

    -- initially we reserve space for 8 buckets
    empty(): % == per [0, newArr 8]
    search(k: Key, x: %): Union(Entry, "failed") ==
        r: Record(idx: N, bidx: N) := localsearch(k, x)
        i := r.bidx
        zero? i => "failed"
        h := r.idx
        (rep(x).arr.h.i.entry)::Union(Entry, "failed")
    keys(x: %): List Key ==
        a := rep(x).arr
        l: List Key := []
        for i in 1..#a repeat
            bucket := a.i
            for j in 1..#bucket repeat l := cons(bucket.j.key, l)
        l
    inspect(x: %): KE ==
        a := rep(x).arr
        for i in 1..#a repeat
            bucket := a.i
            for j in 1..#bucket repeat return bucket j
        error "table must be non-empty"
    #(x: %): N == rep(x).numOfEntries
    elt(x: %, k: Key): Entry ==
        r: Record(idx: N, bidx: N) := localsearch(k, x)
        h := r.idx
        i := r.bidx
        bucket := rep(x).arr.h
        not zero? i => bucket.i.entry
        error "key not in table"
    elt(x: %, k: Key, e: Entry): Entry ==
        r: Record(idx: N, bidx: N) := localsearch(k, x)
        h := r.idx
        i := r.bidx
        bucket := rep(x).arr.h
        not zero? i => bucket.i.entry
        e
    setelt(x: %, k: Key, e: Entry): Entry ==
        r: Record(idx: N, bidx: N) := localsearch(k, x)
        h := r.idx
        i := r.bidx
        bucket := rep(x).arr.h
        not zero? i => bucket.i.entry := e
        concat!(bucket, [k, e])
        -- We choose a load factor of 0.75.
        if 3*(rep(x).numOfEntries := 1 + #x) > 4*#(rep(x).arr) then grow! x
        -- we must insert a new entry
        e
    remove!(ke: KE, x: %): % ==
        r: Record(idx: N, bidx: N) := localsearch(ke.key, x)
        h := r.idx
        i := r.bidx
        zero? i => x
        bucket := rep(x).arr.h
        bucket.i.entry ~= ke.entry => x
        n: N := #bucket
        bucket.i := bucket.n
        delete!(bucket, n)
        rep(x).numOfEntries := (#x::Z - 1)::N
        x
    remove!(k: Key, x: %): Union(Entry, "failed") ==
        r: Record(idx: N, bidx: N) := localsearch(k, x)
        h := r.idx
        i := r.bidx
        zero? i => "failed"
        bucket := rep(x).arr.h
        n: N := #bucket
        e: Entry := bucket.i.entry
        bucket.i := bucket.n
        delete!(bucket, n)
        rep(x).numOfEntries := (#x::Z - 1)::N
        e::Union(Entry, "failed")

    -- copy : % -> %
    copy(x: %): % ==
        n: N := rep(x).numOfEntries
        a := rep(x).arr
        c: FlexibleArray FlexibleArray KE := newArr n
        for i in 1..#a | not empty? a.i repeat c.i := copy a.i
        per [n, c]

    -- fill! : (%,E) -> % if $ has ATSHMUT
    fill!(x: %, e: Entry): % == for ke in parts(x)@List(KE) repeat ke.entry:=e

    -- hash : % -> SingleInteger if E has SETCAT or R has SETCAT
    hash(x: %): SingleInteger == hash(rep(x).numOfEntries) + hash(rep(x).arr)

    -- map! : ((E -> E),%) -> % if $ has ATSHMUT
    map!(f: Entry -> Entry, x: %): % ==
        a := rep(x).arr
        for i in 1..#a repeat
            bucket := a.i
            for j in 1..#bucket repeat
                ke: KE := bucket.j
                ke.entry := f(ke.entry)
        x

    -- parts : % -> List(E) if $ has ATFINAG
    parts(x: %): List Entry ==
        a := rep(x).arr
        l: List Entry := empty()
        for i in 1..#a repeat
            bucket := a.i
            for j in 1..#bucket repeat l := cons(bucket.j.entry, l)
        l

    -- parts : % -> List(R) if $ has ATFINAG
    parts(x: %): List KE ==
        a := rep(x).arr
        l: List KE := empty()
        for i in 1..#a repeat
            bucket := a.i
            for j in 1..#bucket repeat l := cons(bucket.j, l)
        l

    -- removeDuplicates : % -> % if $ has ATFINAG and R has SETCAT
    removeDuplicates(x: %): % == x -- there are no duplicates
@
